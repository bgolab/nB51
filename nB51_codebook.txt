Programming Hints(ideas of language improvement):

NOTE: Remember to add at least 100ms delay when pasting several lines of codes to give some time to the interpreter to accepts copied data

#SW: END: separate from subroutines and main prg

#SW: gettick(): 
-v0.1b2+: for k=1 to 100 print gettick() next k

#SW: pause: 
-v0.1b2+: for k=1 to 100 pause 1000 print gettick() next k 

#SW: non-blocking wait: 
-v0.1b2+: a=gettick(0) wait: if gettick()<1000 then goto wait endif (cannot use func like gettick() w/o var!)
-v0.3b1+: settick 0 wait: if gettick()<1000 then goto wait endif

#HW: W/R XDATA (LUT)
-v0.1b2+: poke 999, 17 print peek(999)
-v0.3b1+: xpoke HS, 17 print xpeek(HS)

#HW: W/R XDATA HEAP space access
-v0.2b1+: heap=peek(0xf00) poke heap,0x7 print peek(heap) // (SYS-MEM @0xf00 contain HEAP start mem addr)
-v0.3b1+: xpoke HS, 17 print xpeek(HS)

#HW:AUXR.6=1: 1T for UART; baudrate change on the fly from 9600 to 115.2
-v0.3b1+: spoke 0x8e, 64

#HW: AUXR
-v0.2b1: print peek(0xc8e)
-v0.3b1+: print speek(0x8e)

#HW: INKEY simulation (probably work because RI is clear periodically since v0.2b1, 0xc99 is remapped sbuff addr to SFR space for peek/poke mem-map)
-v0.2b1+ 
for k=1 to 100
print peek(0xc99)
pause 100
next k

-v0.3b1+: 
for k=1 to 100
print speek(0x99)
pause 100
next k

#HW: W/R SFR(P0): 
-v0.1b1+: spoke 128, 7 print speek(128) (3 lowest bit set and read of the P0)
-v0.3b1+: spoke 128, 7 print speek(128) (3 lowest bit set and read of the P0)

#HW: SP 
-v0.1b1: print speek(129)
-v0.1b2+: print peek(0xc81)
-v0.3b1+: print speek(0x81)

#HW: TL1: 
-v0.1b1+: print speek(139)
-v0.1b2+: print peek(0xc8b)
-v0.3b1+: print speek(0x8b)

#HW: watchdog reboot (the program still kept in the memory - check w/ 'c' command)
-v0.1b1: spoke 193, 32 
-v0.1b2+: poke 0xcc1, 32
-v0.3b1+: spoke 0xc1, 32

#HW: OUT(LED): P5.5/P5.4-charlie plexing; AIAPP-generated-code:P5M0|=0x30; P5M1&=~0x30(P5M0=0xCA;P5M1=0xC9;P5=0xc8); 
-port-cfg: 			0xCA SR 0x30 | 0xCA SWAP SW 0xC9 SR 0x30 ~ & 0xC9 SWAP SW 
-blink(normal): 	0xc8 PA L0:   A 0x10 SW   A 0 SW JMP L0
-blink(reversed): 	0xc8 PA L0:   A 0x20 SW   A 0 SW JMP L0
-v0.1b1 - with speek/spoke, no address remapping
a=speek(0xca) b=or(a,0x30) spoke 0xca,b
a=speek(0xc9) c=not(0x30) b=and(a,c) spoke 0xc9,b
a=0xc8 spoke a,0x10 spoke a, 0
a=0xc8 spoke a,0x20 spoke a, 0
-----------------------------------------------------
-v0.1b1 - with speek/spoke, no hex, no address remapping (reversed polarity)
a=speek(202) 
spoke 202,or(a,48)
a=speek(201)
spoke 201,and(a,not(48))
spoke 200,32
pause 500
spoke 200,0
-----------------------------------------------------
-v0.1b2 - no speek/spoke, hex, remapped SFR addresses to 0xc00+SFR (reversed polarity)
cfg1=0xcca
a=peek(cfg1)
b=or(a,0x30)
poke cfg1,b

cfg2=0xcc9
a=peek(cfg2)
c=not(0x30)
b=and(a,c)
poke cfg2,b

p5=0xcc8
for k=1 to 10 
poke p5,0x20
pause 500
poke p5,0
pause 500
next k

-v0.1b2 - no speek/spoke, hex, remapped SFR addresses to 0xc00+SFR (reversed polarity)
c=0xcca
poke c,or(peek(c),0x30)

c=0xcc9
poke c,and(peek(c),not(0x30))

p=0xcc8
for k=1 to 10 
poke p,0x20
pause 500
poke p,0
pause 500
next k

-v0.3b1 - introduced SPEEK/SPOKE/XPEEK/XPOKE
c=0xca
spoke c,or(speek(c),0x30)

c=0xc9
spoke c,and(speek(c),not(0x30))

p=0xc8
for k=1 to 10 
spoke p,0x20
pause 500
spoke p,0
pause 500
next k

#FW: XSFR
-v0.3b1 - hw multiply (simplified - small numbers)
 MD3  0xfcf0
 MD2  0xfcf1
 MD1  0xfcf2
 MD0  0xfcf3
 MD5  0xfcf4
 MD4  0xfcf5
 ARCON  0xfcf6
 OPCON  0xfcf7
 sfr P_SW2 = 0xBA;
 ---
P_SW2 |= 0x80; 				// Access to the extended register xsfr
MD1 = dat1; 				//dat1 is given by user
MD5 = dat2; 				//dat2 is given by user
ARCON = 4 << 5; 			//16 bit*16 bit, multiply mode
OPCON = 1; 					//start calculation
while((OPCON & 1) != 0); 	//wait for the calculation complement
res = MD3U32; 				//32 bit result
---
16bit(MD1...MD0, little endian) * 16bit(MD5...MD4, little endian)=32bit(MD3...MD0, little endian)
---
PSW2=0xBA
MD1=0xfcf2
MD5=0xfcf4
MD3=0xfcf0
ARCN=0xfcf6
OPCN=0xfcf7
SPOKE PSW2, OR( SPEEK(PSW2), 0x80)
XPOKE MD1, 12
XPOKE MD5, 15
XPOKE ARCN, 128
XPOKE OPCN, 1
WAIT: IF AND(SPEEK(OPCN),1)<>0 THEN PRINT "!" GOTO WAIT ENDIF
PRINT XPEEK(MD3)
PRINT XPEEK(MD3+1)
r
0
180

-v0.3b1 - hw division
 MD3  0xfcf0
 MD2  0xfcf1
 MD1  0xfcf2
 MD0  0xfcf3
 MD5  0xfcf4
 MD4  0xfcf5
 ARCON  0xfcf6
 OPCON  0xfcf7
 sfr P_SW2 = 0xBA;
 ---
P_SW2 |= 0x80; 				// Access to the extended register xsfr
MD3U32 = dat1; 				//dat1 is given by user
MD5U16 = data2; 			//dat2 is given by user
ARCON = 6 << 5; 			//32 bit/16bit, division mode
OPCON = 1; 					//start calculation
while((OPCON & 1) != 0); 	// wait for the calculation complement
res = MD3U32; 				//32-bit quotient, 16-bit remainder in MD5
---
32bit(MD3...MD0, little endian)/16bit(MD5...MD4, little endian)=32bit(MD3...MD0-result, MD5-MD4-remainder, little endian)
---
PSW2=0xBA
MD5=0xfcf4
MD4=0xfcf5
MD3=0xfcf0
MD2=0xfcf1
MD1=0xfcf2
MD0=0xfcf3
ARCN=0xfcf6
OPCN=0xfcf7
SPOKE PSW2, OR( SPEEK(PSW2), 0x80)
XPOKE MD3, 130
XPOKE MD2, 0
XPOKE MD1, 0
XPOKE MD0, 0
XPOKE MD5, 2
XPOKE MD4, 0
XPOKE ARCN, 192
XPOKE OPCN, 1
WAIT: IF SPEEK(OPCN)<>0 THEN GOTO WAIT ENDIF
PRINT XPEEK(MD3)
PRINT XPEEK(MD2)
PRINT XPEEK(MD5)




